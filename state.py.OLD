# state.py
# Structure for the combat state vector (and subsequent sub-structures)
# Supports JSON-encoded I/O
# Members can be initalized from file

# Going idea: Main state class holds all data as dict for easy I/O manipulation
# Supports helper functions to return class representations of Member and Buff objects
# Those will populate default values (so state storage is smaller) and are generated as requested

import json
# from types import Pip

# < Member stats located in types.py >

# State class
# States are stored as dictionaries, so this class serves as a wrapper for
#   state modification operations (such as adding a charm to a participant)
class State:
	def parse(string: str) {
		# First attempt to parse the string as a JSON-encoded dictionary
		try: return json.loads(str)
		except json.decoder.JSONDecodeError: pass

		# Otherwise, attempt to open the path
		try:
			with open(str) as f:
				return json.load(f)
		
		except FileNotFoundError, json.decoder.JSONDecodeError:
			raise ValueError
	}

	def load(self, data: dict) {
		# Check for only the known values
		# (On the chance the state file is messed up, we don't want to pass around extraneous data)
		# for (key, value) in self.data.items()
		for key in self.data:
			try: self.data[key] = data[key]
			except KeyError: continue
	}

	def __init__(self, data = None):
		self.data = {
			"round" : 1,			# NOTE: Pips should be acquired at the start of the player turn, if applicable
			"first" : 0,			# Should be either 0 or 4 (wizards first or npcs first)
			"player" : 0			# Index of casting participant
			"bubble" : None			# If none, the class helper will parse accordingly
			"order" = [None for x in range(8)]		# Array of member IDs to define cast order
			"members" = {}			# Dict of (member_id, member_data) : Allows for more than 8 member states for battles that require it
		}

		if isinstance(data, str):
			try: data = State.parse()
			except ValueError:
				print("WARNING: State data could not be parsed from json string or path")
				return
		self.load(data)


# -- HELPER OBJECTS --
# The simulation expects a specific structure for computing damage values or state distributions
# These are generated by calls to the parent State object when needed, and provide member functions for data manipulation
# The class assumes default values of 0, so that the state object stores less data

# Stats 'buff' object
# Defines modifications to stats (for use in respective calculations)
# Examples include: Blades, Auras, Globals, etc.
class Buff:
	pass


# Core member state object
# Defines dynamic state parameters (health, pips, blades, etc.)
class Member:
	def __init__(self):
		self.health = 1000
		# self.mana = 100		# Mana currently ommitted intentionally (adds dimensionality with no real benefit)
		# self.pips = [Pip.NONE for x in range(7)]	# Initial pips gained at the start of P1's turn
		self.shads = 0





#################################################################
#################################################################





# Status effects state object
# Groups status effects into one
class Status:
	def __init__(self):
		self.stunned = 0
		self.beguiled = 0
		self.confused = 0

# Parent state object
# Defines necessary battle conditions
# TODO: Consider refactor where no values are initalized
#   Instead there exists a class member 'defaults' that houses all the default values
#   When saving the state, check only for member values that are not None
#   All accesses should be performed through getters (and probably setters)
class StateOld:
	def __init__(self, data = None):
		if type(data) == State: 
			self.populate(data)
			return

		self.init()
		if type(data) == str: self.parse(data)
	
	# Load all values with defaults
	def init(self):
		# Primary battle values
		self.round = 1			# NOTE: Pips should be acquired at the start of the player turn, if applicable
		self.player = 0
		self.first = 0			# Should be either 0 or 4 (wizards first or npcs first)
		# self.global = None		# Buff object
		self.order = [None for x in range(8)]		# Array of memberID to specify order

		# Member-specific traits
		self.members = {}		# Dict of member states (key: memberID;  value: <state.member>)

	# Duplicate a state
	# Essentially a manual deepcopy
	def duplicate(self):
		return State(self)

	# Substitute state values as read from JSON-encoded string
	def parse(self):
		pass